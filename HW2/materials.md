**Керуючі конструкції. Винятки**
```
name = input("What is your name? ")
print(f"Hello {name}")
```
За замовчуванням у Python інструкції виконуються одна за одною зверху вниз. У прикладі дві інструкції — спочатку виконується name = input("What is your name? "), потім print(f"Hello {name}").

Послідовність виконання виразів в програмі називається «потік виконання» (Flow of execution).

У Python існує три способи управління потоком виконання:

умовне виконання — виконання блоку інструкцій тільки при настанні деякої умови;
цикли — повторення виконання блоку інструкцій, доки виконується деяка умова;
винятки — виконання блоку інструкцій у разі помилки.
Умовне виконання
```
age = input("How old are you? ")

if int(age) >= 18:
    print("You are adult already.")
else:
    print("You are infant yet.")
```
У Python реалізований оператор контролю виконання (умовний оператор) if ... elif ... else.

Оператор контролю виконання дозволяє виконувати блоки інструкцій не завжди, а тільки тоді, коли буде виконана умова.

Синтаксис умовного оператора:

починається з ключового слова if, за яким йде умова;

після умови ставиться двокрапка і з нового рядка з відступом йде блок інструкцій, які будуть виконані, якщо умова виконується;

після блоку if може бути нуль або більше блоків elif, інтерпретатор послідовно перевірятиме усі умови elif зверху вниз, доки не знайде той, який виконується;

потім може бути один блок else, який виконується, якщо всі попередні умови не виконуються.
```
a = input('Введіть число')
a = int(a)
if a > 0:
    print('Число додатне')
elif a < 0:
    print("Число від'ємне")
else:
    print('Це число - нуль')
```
Під час виконання умовного оператора інтерпретатор Python перевіряє умови зверху вниз, доки не знайде те, яке виконується, потім виконає вираз для цієї умови та вийде з перевірки умов.
```
a = input('Введіть число')
a = int(a)
if a > 0:
    print('Число додатне')
elif a == 1:
    print('Число дорівнює 1')
else:
    print("a <= 0")
```
В такому випадку код для умови a == 1 ніколи не виконається.

Умови у Python
Умовний оператор if ... elif ... else у Python у якості умов може приймати змінні типу bool або будь-який вираз, який він виконає і результат перетворить в bool.

Логічні вирази
Коли в якості умови в умовний оператор ми передаємо вираз, то вираз виконається, а результат його виконання буде перетворений в тип bool.

Для зручності у Python є механізм неявного приведення будь-якого типу до типу bool. Правила приведення до bool — інтуїтивні:

число 0 приводиться до False (ціле, дробове або комплексне);
```
money = 0
if money:
    print(f"You have {money} on your bank account")
else:
    print("You have no money and no debts")

None приводиться до False;

result = None
if result:
    print(result)
else:
    print("Result is None, do something")

порожній контейнер (порожній рядок тощо) приводиться до False

user_name = input("Enter your name: ")

if user_name:
    print(f"Hello {user_name}")
else:
    print("Hi Anonym!")
```
все інше приводиться до True

Правила приведення до bool дозволяють писати умовні вирази у Python практично літературною англійською. В будь-якому разі, такий код стає дуже зрозумілим.

Булева алгебра
Що робити, якщо у нас складна умова, яка поєднує в собі декілька вкладених умов? Наприклад, щоб користувач міг орендувати автомобіль, потрібно, щоб у користувача обов'язково було вказане ім'я, користувач був старший 18 і були водійські права.
```
name = "Taras"
age = 22
has_driver_licence = True

if name and age >= 18 and has_driver_licence:
    print(f"User {name} can rent a car")
```

Для побудови логічних умов з декількох, використовується булева алгебра.

Булева алгебра — це розділ математичної логіки, в якому вивчаються логічні операції над висловлюваннями.

У програмуванні застосовують бінарну логіку, можливі значення для бінарної логіки можуть бути True та False.

Булева алгебра будується на трьох основних операціях: "І", "АБО", "НЕ". Є ще допоміжні, але давайте поки що розглянемо основні.

У Python оператори булевої алгебри — це оператори not, and, or.

and (І) вираз виконується, якщо обидві умови виконуються
```A	B	A and B
True	True	True
True	False	False
False	True	False
False	False	False
a = True and False  # False

or (АБО) вираз виконується, якщо хоча б одна з умов виконується
A	B	A or B
True	True	True
True	False	True
False	True	True
False	False	False
a = True or False  # True

not (НІ) заперечення, вираз виконується, якщо операнд — неправда
A	not A
True	False
False	True
a = not 2 < 0  # True
```
Тернарні операції
Тернарні оператори — це ті самі умовні вирази, але в скороченій формі. Ці оператори повертають щось, залежно від того, чи є умова істиною або брехнею.

is_nice = True
state = "nice" if is_nice else "not nice"

У цьому прикладі у state буде рядок 'nice'.

Такий підхід дозволяє швидко перевірити умову, а не писати декілька рядків оператора if ... else ....

У Python також існує коротший варіант тернарного оператора.

some_data = None
msg = some_data or "Не було повернено даних"

У цьому прикладі msg містить рядок 'Не було повернено даних', це зручно, коли потрібно швидко перевірити значення та показати повідомлення, якщо значення None.

Зверніть увагу, що для скороченої форми використовується саме оператор or (АБО).

Блоки інструкцій
```x = int(input("X: "))
y = int(input("Y: "))

if x == 0:
    print("X can`t be equal to zero")
    x = int(input("X: "))

result = y / x
```
У Python особливий синтаксис стосовно виділення блоків інструкцій. Щоб інтерпретатор сприйняв набір інструкцій як окремий блок, достатньо виділити всі інструкції цього блоку однаковою кількістю відступів зліва. У Python рекомендується для виділення одного рівня вкладеності для блоку інструкцій використовувати 4 пробіли.

Ви можете використати символи табуляції для виділення блоку інструкцій, це не помилка, але такий спосіб не рекомендується.

Синтаксичною помилкою буде змішати в одному файлі виділення блоків за допомогою табуляцій та пробілів одночасно.

Ви також можете виділяти декілька рівнів вкладеності, додаючи ще 4 пробіли зліва для всіх інструкцій блоку:

```x = int(input("X: "))
y = int(input("Y: "))

if x == 0:
    print("X can`t be equal to zero")
    x = int(input("X: "))

    if x == 0:
        print("X can`t be equal to zero")
        x = int(input("X: "))

        if x == 0:
            print("X can`t be equal to zero")
            x = int(input("X: "))

result = y / x
```

В цьому прикладі тричі повторюється перевірка на нерівність x нулю, і на кожну перевірку блок інструкцій виділяється додатковими 4-ма пробілами.

Приклад вкладеності для визначення чвертей для координатної площини.

```if x >= 0:
    if y >= 0:               # x > 0, y > 0
        print("Перша чверть")
    else:                    # x > 0, y < 0
        print("Четверта чверть")
else:
    if y >= 0:               # x < 0, y > 0
        print("Друга чверть")
    else:                    # x < 0, y < 0
        print("Третя чверть")
```
Цикли
Для того, щоб повторити якийсь блок коду кілька разів або повторювати, доки виконується деяка умова, у Python реалізовані цикли. Існує два види циклів:

цикл for, який ще називають ітеруючим, він перебирає усі елементи деякої послідовності;
цикл while, який виконується, доки виконується деяка умова.
Ітерація (лат. iteratio «повторювання») — повторювання будь-якої дії. Ітерація у програмуванні — організація обробки даних, за якої дії повторюються багаторазово, не призводячи, при цьому, до викликів самих себе.

Одна ітерація — це одне повторювання.

Цикл for
У Python цикл for використовується для перебору усіх елементів контейнерів або ітерованих об'єктів, наприклад, списків. Інструкції, які знаходяться у тілі циклу, будуть виконані стільки разів, скільки елементів у списку.

При цьому на кожній ітерації спеціальна змінна набуває значення одного з елементів списку.

Роботу циклу for можна порівняти з тим, що ви по черзі візьмете кожну літеру з фрази й промовите її. Фразою буде виступати рядок 'apple', а аналогом вимовлення вголос буде виступати виведення відповідної літери в консоль.
```
fruit = 'apple'
for char in fruit:
    print(char)
```
У результаті виконання цього коду ви побачите в консолі:

a
p
p
l
e

Синтаксис циклу for:

цикл розпочинається з ключового слова for;
за яким обов'язково йде назва змінної, куди записуватиметься значення, що отримується з ітерованого об'єкту на кожній ітерації;
далі слідує ключове слово in;
за яким обов'язково йде вираз або об'єкт, по якому, власне, буде ітеруватися for;
далі ставиться :;
і з нового рядка з відступом йде набір виразів, які повторюватимуться на кожній ітерації
Цикл while
Цикл while дозволяє виконати інструкції, які знаходяться у тілі циклу до тих пір, доки виконується умова, вказана в циклі. Наприклад, цикл while, який виводить числа від 1 до 5:
```
a = 1
while a <= 5:
    print(a)
    a = a + 1
```
«Нескінченні цикли» та break
Бувають ситуації, коли необхідно вийти з циклу до завершення ітерації, не дочекавшись, доки станеться чергова перевірка умови. Для цього є команда break. Команда break зупиняє цикл в момент виклику і не завершує ітерацію.
```
a = 0
while True:
    print(a)
    if a >= 20:
        break
    a = a + 1
```
В цьому прикладі умова циклу буде виконуватися завжди, адже True завжди буде True. Це приклад нескінченного циклу. Але через перевірку, що a >= 20, цей цикл завершиться, щойно в a буде значення 20 або більше.

Нескінченні цикли часто застосовуються там, де потрібно взаємодіяти з клієнтом, чекаючи введення від нього, і завершується тільки при настанні деякої умови.

Наприклад echo скрипт, який виводить в консоль те, що ви введете, доки ви не введете exit:
```
while True:
    user_input = input()
    print(user_input)
    if user_input == "exit":
        break
```
Завершення ітерації за допомогою continue
Також для того, аби одразу перейти до наступної ітерації циклу без виконання виразів, що залишилися, є команда continue. Виклик цієї команди у тілі циклу призводить до того, що вирази цієї ітерації, що залишилися, не будуть виконані, а інтерпретатор одразу перейде до наступної ітерації або перевірки умови.
```
a = 0
while a < 6:
    a = a + 1
    if not a % 2:
        continue
    print(a)
```
У консолі ви побачите:

1
3
5

Інструкція print(a) не виконувалась, коли a ділилося на 2 без залишку, оскільки ітерація завершувалася за допомогою continue.

В цьому прикладі використовувався оператор отримання залишку від ділення %, він повертає таке число p, що якщо його відняти від r, то результат буде ділитися на x націло:

(r - p) / x = a,

де а, x, r — цілі числа.

Оператори continue та break працюють тільки всередині одного циклу. В ситуації вкладених циклів немає способу вийти з усіх циклів одразу.
```
while True:
    number = input("number = ")
    number = int(number)
    while True:
        print(number)
        number = number - 1
        if number < 0:
            break
```
В цьому прикладі користувач вводить число та отримує зворотний відлік від цього числа до 0 в консолі. При цьому, зовнішній нескінченний цикл жодним чином не перервати і break вийде тільки з внутрішнього циклу.

Також використання continue або break поза циклом призводить до синтаксичної помилки.
```
number = int(input("number = "))
if number < 0:
    break
```
Такий код призводить до помилки SyntaxError. Такі помилки називаються виключеннями.

Винятки
Перетворити в int або float можна не будь-який рядок. Наприклад, якщо користувач введе 'a', то інтерпретатор не зможе визначити, як перетворити символ a в ціле число, і викличе виняток ValueError.
```
int("a")
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-6-d9136db7b558> in <module>
----> 1 int("a")

ValueError: invalid literal for int() with base 10: 'a'
```

Виключення у Python — це помилка на рівні інтерпретатора, викликана неможливістю виконати той або інший оператор з будь-яких причин (змінна не існує, синтаксична помилка, відсутній атрибут, операція ділення на нуль тощо).

У нашому прикладі (ввели 'а') інтерпретатор намагається перетворити рядок в тип int (ціле число), але як перетворити рядок 'a' у число не визначено і буде викликаний виняток із цього приводу.

Механізм обробки винятків
Для обробки винятків існує оператор try ... except .... Синтаксично, цей оператор розпочинається з ключового слова try: (спробувати) та продовжується блоком коду, в якому ми чекаємо, що може статися помилка.

Далі йде блок обробки винятків except (крім), де можна вказати один або більше винятків. Якщо один із зазначених винятків станеться, то виконається наступний блок коду.

Цей блок не обов'язковий, але найчастіше потрібний. Він виконається, якщо станеться зазначений виняток (один із них, якщо їх декілька).

Якщо помилки можуть бути різні і обробляти їх потрібно теж по-різному, то можна додати декілька блоків except, у кожному вказати свою помилку і що робити, якщо вона станеться.

Потім йде необов'язковий блок, який розпочинається з ключового слова else. Цей код виконається, тільки якщо винятків не сталося.

Останнім йде необов'язковий блок коду, який розпочинається з ключового слова finally, він виконається у будь-якому разі, незалежно від того, були помилки або ні.

У нашому прикладі обробка призначеного для користувача введення виглядатиме таким чином:
```
val = 'a'
try:
    val = int(val)
except ValueError:
    print(f"val {val} is not a number")
else:
    print(val > 0)
finally:
    print("This will be printed anyway")
````
Винятки у Python — це дуже потужний інструмент, який часто використовується для управління потоком виконання, а не тільки для обробки помилок. У динамічних мовах ніколи не можна бути на 100% впевненим у тому, що користувач ввів значення коректного типу або, що інший застосунок не повернув None, замість int, наприклад.

Наївним розв'язання цієї проблеми буде повсюдне використання перевірок if на коректність введеного користувачем або іншим застосунком значення. Просунутішим, зручнішим і прозорішим рішенням є використання механізму обробки винятків там, де вони можуть статися через некоректні вхідні дані.

```age = input("How old are you? ")
try:
    age = int(age)
    if age >= 18:
        print("You are adult.")
    else:
        print("You are infant")
except ValueError:
    print(f"{age} is not a number")
```

Основні типи виключень у Python
SyntaxError — синтаксична помилка.

IndentationError — помилка, яка виникає, якщо у виділенні блоків інструкцій пробілами припущена помилка.

TabError виникає, якщо в одному файлі використовувати пробіли і табуляції для виділення блоків інструкцій.

TypeError виникає, коли операція зі змінною цього типу неможлива.

`2 / 'a'`

ValueError виникає, коли тип операнда відповідний, але значення таке, що операцію неможливо виконати.

`int("a")`

ZeroDivisionError — ділення на нуль.

**Функції**

Функції – це фрагменти програми, які багаторазово використовуються. Вони дозволяють дати ім'я певному блоку команд для того, щоб згодом запускати цей блок за вказаним ім'ям у будь-якому місці програми і скільки завгодно разів. Це називається викликом функції.

Створення та виклик функцій
Функції визначаються за допомогою зарезервованого слова def. Після цього слова вказується ім'я функції, за яким йде пара дужок, у яких можна вказати імена деяких змінних, та заключна двокрапка в кінці рядка. Далі слідує блок команд, що складають функцію. На прикладі можна бачити, що насправді це дуже просто:
```
def say_hello():
    print('Привіт, Світ!')   # блок, що належить функції
    # Кінець функції say_hello()

# виклик функції
say_hello()

# ще один виклик функції
say_hello()
```
Ми визначили функцію з ім'ям say_hello, використовуючи описаний вище синтаксис. Ця функція не приймає параметрів, тому в дужках не оголошені якісь змінні. Параметри функції – це деякі вхідні дані, які ми можемо передати функції, щоб отримати результат, що відповідає їм.

Аргументи функції
Функції можуть приймати параметри, тобто деякі значення, що передаються функції для того, щоб вона щось зробила з ними. Ці параметри схожі на змінні, за виключенням того, що значення цих змінних вказуються при виклику функції, та під час роботи функції їм вже присвоєні їх значення. Параметри вказуються в дужках при оголошенні функції та розділяються комами. Аналогічно ми передаємо значення, коли викликаємо функцію. Зверніть увагу на термінологію: імена, вказані при оголошенні функції, називаються параметрами, тоді як значення, які ви передаєте у функцію при її виклику, – аргументами.
```
def print_max(a, b):
    if a > b:
        print(a, 'максимально')
    elif a == b:
        print(a, 'дорівнює', b)
    else:
        print(b, 'максимально')

print_max(3, 4)  # пряма передача значень

x = 5
y = 7
print_max(x, y)  # передача змінних у якості аргументів
```
Тут ми визначили функцію з ім'ям print_max, яка використовує два параметри з іменами a та b. Ми знаходимо найбільше число із застосуванням простого оператора if..else та виводимо це число. При першому виклику функції print_max ми напряму передаємо числа як аргументи. У другому випадку ми викликаємо функцію зі змінними як аргументи, print_max(x, y) призначає значення аргументу x параметру a, а значення аргументу y – параметру b. В обох випадках функція print_max працює однаково.

Повернення результату
У Python немає синтаксичної різниці між функціями і процедурами. По суті, функція вміє повертати деякий результат своєї роботи, а процедура нічого не повертає та результатом її роботи може бути зміна стану вже існуючих змінних. Така форма використання функцій максимально наближена до функцій, з якими ми знайомі з уроків математики.

Для повернення значення з функції необхідно вказати, що повернути після ключового слова return. Наприклад, функція, що виконує операцію додавання.
```
def plus(a, b):
  c = a + b
  return c

res = plus(3, 4)
print(res)  # Виведе 7

Або ще коротше:

def plus(a, b):
  return a + b

print(plus(3, 4))   # Виведе 7
```
Локальні змінні
При оголошенні змінних всередині визначення функції вони жодним чином не пов'язані з іншими змінними з таким самим ім'ям за межами функції, тобто імена змінних є локальними у функції. Це називається областю видимості змінної. Область видимості усіх змінних обмежена блоком, в якому вони оголошені, починаючи з точки оголошення імені.
```
x = 50

def func():
    x = 2
    print('Зміна локального x на', x)  # Зміна локального x на 2

func()
print('x як і раніше', x)   # x як і раніше 50
```
Далі ми назначаємо x значення 2 всередині функції func, але це "локальний" x, який жодним чином не впливає на "глобальний" x поза тілом функції. Тому коли ми заміняємо значення x у функції, x, оголошений в основному блоці, залишається незачепленим. Останнім викликом функції print ми виводимо значення x, вказане в основному блоці, підтверджуючи таким чином, що воно не змінилося при локальному присвоюванні значення в раніше викликаній функції.

Global
Щоб присвоїти деяке значення змінній, визначеній на вищому рівні програми (тобто не у якійсь зоні видимості, як функції), необхідно вказати Python, що її ім'я не локальне, а глобальне (global). Зробимо це за допомогою зарезервованого слова global. Без застосування зарезервованого слова global неможливо присвоїти значення змінній, визначеній за межами функції.
```
x = 50

def func():
    global x
    print('x дорівнює', x) # x дорівнює 50
    x = 2
    print('Змінюємо глобальне значення x на', x)   # Змінюємо глобальне значення x на 2

func()
print('Значення x складає', x)   # Значення x складає 2
```
Зарезервоване слово global використовується для того, щоб оголосити, що x – це глобальна змінна, а значить, коли ми присвоюємо значення імені x всередині функції, ця зміна відобразиться на значенні змінної x в основному блоку програми. Використовуючи одне зарезервоване слово global, можна оголосити відразу декілька змінних: global x, y, z. Використовувати global варто з великою обережністю і не потрібно зловживати такою можливістю.

Ключові аргументи
Якщо є деяка функція з великою кількістю параметрів, і при її виклику вимагається вказати тільки деякі з них, значення цих параметрів можуть задаватися за їх ім'ям – це називається ключові параметри. В цьому випадку для передачі аргументів функції використовується ім'я (ключ), замість позиції (як було досі). Є дві переваги такого підходу: по-перше, використання функції стає легшим, оскільки немає потреби відстежувати порядок аргументів; по-друге, можна задавати значення тільки деяким обраним аргументам, за умови, що інші параметри мають значення аргументу за замовчуванням.
```
def func(a, b=5, c=10):
    print('a дорівнює', a,', b дорівнює', b,', а c дорівнює', c)

func(3, 7)          # a дорівнює 3, b дорівнює 7, а c дорівнює 10
func(25, c=24)      # a дорівнює 25, b дорівнює 5, а c дорівнює 24
func(c=50, a=100)   # a дорівнює 100, b дорівнює 5, а c дорівнює 50
```
Функція з ім'ям func має один параметр без значення за замовчуванням, за яким слідують два параметри зі значеннями за замовчуванням. При першому виклику func(3, 7), параметр a отримує значення 3, параметр b отримує значення 7, а c отримує своє значення за замовчуванням, що дорівнює 10.

При другому виклику func(25, c=24) змінна a отримує значення 25 на підставі позиції аргументу. Після цього параметр c отримує значення 24 за ім'ям, тобто як ключовий параметр. Змінна b отримує значення за замовчуванням, що дорівнює 5.

При третьому зверненні func(c=50, a=100) ми використовуємо ключові аргументи для усіх вказаних значень. Зверніть увагу на те, що ми вказуємо значення для параметра c перед значенням для a, навіть попри те, що у визначенні функції параметр a вказаний раніше c.
```
def say(message, times=1):
    print(message * times)

say('Привіт')   # Привіт
say('Світ', 5)   # СвітСвітСвітСвітСвіт
```
Функція з ім'ям say використовується для виведення на екран рядка, вказаного число разів. Якщо ми не вказуємо значення за замовчуванням, рядок виводиться один раз. Ми досягаємо цього зазначенням значення аргументу за замовчуванням, що дорівнює 1 для параметра times. При першому виклику say ми вказуємо тільки рядок, і функція виводить його один раз. При другому виклику say ми вказуємо також і аргумент, позначаючи таким чином, що ми хочемо сказати фразу 5 разів.

Значеннями за замовчуванням можуть бути забезпечені тільки параметри, що знаходяться у кінці списку параметрів. Таким чином, у списку параметрів функції параметр зі значенням за замовчуванням не може передувати параметру без значення за замовчуванням. Це пов'язано з тим, що значення надаються параметрам відповідно до їх положення. Наприклад, def func(a, b=5) — допустимо, а def func(a=5, b) – не допустимо.

Змінна кількість параметрів
Іноді буває необхідно визначити функцію, здатну приймати будь-яку кількість параметрів. Цього можна досягти за допомогою зірочок:
```
def total(a=5, *numbers, **phone_book):
    print('a', a)
    # прохід по всіх елементах кортежу
    for single_item in numbers:
        print('single_item', single_item)

    #прохід по всіх елементах словника
    for first_part, second_part in phone_book.items():
        print(first_part,second_part)

print(total(10, 1, 2, 3, Jack=1123, John=2231, Inge=1560))
```
В результаті в консолі ми побачимо:
```
a 10
single_item 1
single_item 2
single_item 3
Jack 1123
John 2231
Inge 1560
None
```
Коли ми оголошуємо параметр із зірочкою (наприклад, *numbers), всі позиційні аргументи, починаючи з цієї позиції до кінця, будуть зібрані в кортеж під ім'ям numbers. Аналогічно, коли ми оголошуємо параметри із двома зірочками (**phone_book), всі ключові аргументи, починаючи з цієї позиції до кінця, будуть зібрані в словник під ім'ям phone_book.

Контейнери для зберігання аргументів функцій
Для зберігання "зайвих" аргументів застосовуються контейнери Python, кортежі і словники. У ці контейнери збираються усі аргументи, які не визначені вами явно, але вони були передані при виклику функції.

Звичайно, в контейнери Python збирає аргументи, тільки якщо ви вкажете зробити так за допомогою синтаксису з * і/або **.

У прикладі вище numbers — це кортеж, а phone_book — словник.

Кортежі
Кортежі у Python — це впорядковані незмінні множини елементів. Елементом кортежу може бути будь-який тип даних. Кортежі не можна змінювати, не можна додавати/видаляти/переставляти елементи.

Щоб створити порожній кортеж, існують два способи, хоча і не зовсім зрозуміло навіщо потрібний порожній кортеж :-)
```
my_tuple = tuple()
another_tuple = ()

Створення ж непорожніх кортежів відбувається наступним чином:

not_empty = (1, 2, 3)

Доступ до елементів кортежу відбувається за індексом за допомогою синтаксису квадратних дужок:

not_empty = (2, 4, 6)
not_empty[0]    # 2
not_empty[1]    # 4
not_empty[2]    # 6
```
Індексом слугує суворо ціле число. Індексація починається з 0. Ще з кортежами вміє працювати цикл for та може одразу перебрати усі елементи кортежу, як в прикладі з total.

Словники
Словник — це контейнер, який зберігає пари ключ-значення. Ключем може бути будь-який незмінний тип даних Python (число, рядок, кортеж тощо). Значенням словника може бути будь-який тип даних Python, включаючи призначені для користувача типи.

Порожній словник можна створити одним з двох способів:

empty_dict = {}
another_empty_dict = dict()

Створити непорожній словник можна наступним чином:
```
some_dict = {
    "key": "value",
    1: "one",
}
```
Для створення заповненого деякими значеннями словника, достатньо перелічити пари ключ-значення через кому всередині фігурних дужок, ключ йде першим, потім двокрапка та значення.

У прикладі показано застосування в якості ключів рядка і числа.

Запис пари ключ-значення у вже існуючий словник відбувається за допомогою квадратних дужок і оператора присвоєння =:
```
not_empty = {"key": "value"}
not_empty["new_key"] = "new value"
print(not_empty)    # {"key": "value", "new_key": "new value"}
```
Рекурсія

Рекурсивна функція — це функція, що визначається в термінах самої себе і здатна викликати саму себе. Це означає, що функція викликатиме себе і повторюватиме свою поведінку до тих пір, доки не буде виконана деяка умова для повернення результату.

Найчастіший приклад використання рекурсивних функцій — це обчислення факторіалу. Спершу нагадаємо визначення факторіалу з математики: факторіал натурального числа n визначається як добуток усіх натуральних чисел від 1 до n включно. Наприклад: 5! = 1 · 2 · 3 · 4 · 5 = 120. Це саме визначення можна записати рекурсивно:
```
5! = 5 · 4!
4! = 4 · 3!
3! = 3 · 2!
2! = 2 · 1!
1! = 1
def factorial(n):
    if n <= 1:
        return 1
    else:
        return n * factorial(n - 1)

factorial(5)    # 120
```
Ми визначили функцію factorial, яка приймає як аргумент деяке число n. Якщо n менше або дорівнює 1, то факторіал такого числа вже відомий та дорівнює 1. В іншому випадку , щоб знайти факторіал числа n, потрібно помножити n на факторіал n - 1, а факторіал n - 1 ми знаходимо, використовуючи функцію factorial. Викликати ж factorial ми будемо до тих пір, доки на черговій ітерації n не стане менше або дорівнює 1.

Рекурсивні функції зручні в ситуаціях, коли ми не знаємо заздалегідь, скільки разів потрібно буде викликати функцію, наприклад, при розборі папок на диску. Застосунок не знає заздалегідь, наскільки глибока структура папок і який у них рівень вкладеності. І щоб перебрати усі файли в усіх вкладених папках, функція повинна викликати сама себе, коли зустрічає чергову папку. Така функція, яка викликає сама себе за деяких умов, називається рекурсивною.

Імпорт пакетів та модулів
У Python є великий набір пакетів та модулів з готовими корисними функціями та інструментами. Якщо вам потрібно зробити щось, чого немає в стандартному невеликому наборі функцій, ви можете імпортувати пакет, де є необхідна функція, щоб скористатися нею. Імпортування у Python відбувається за допомогою ключового слова import, після якого ви можете вказати один або декілька пакетів, які ви хочете імпортувати.
```
import math

sin_pi = math.sin(math.pi)

У цьому прикладі ми імпортували пакет математичних функцій і констант math та зберегли значення синуса π у sin_pi

Для того щоб викликати функцію з імпортованого пакету, потрібно вказати ім'я пакету і через крапку ім'я функції або константи в цьому пакеті. Цей синтаксис дуже схожий на виклик метода, ми робили так зі словниками та списками раніше.

Є й інший спосіб: можна імпортувати з пакета тільки те, що нам необхідно за допомогою виразу from ... import ...:

from math import pi, sin

sin_pi = sin(pi)
```
Цей код робить те саме, що і код вище. Використовуйте той синтаксис, який вам здається зручнішим.

Імпортувати код можна не лише із стандартних або встановлених пакетів (модулей), але й з власноручно написаних модулів Python.

Модулем Python є будь-який текстовий файл з розширенням py, який містить код мовою Python. Це означає, що коли ви створюєте скрипт hello.py, який містить ось такий код:
```
def say_hello(name):
    print(f'Hello {name}')

```
ви можете імпортувати функцію say_hello з hello.py за домопогою виразу: from hello import say_hello у будь-якому модулі в тій самій папці, що і hello.py.

Це дуже зручно і дозволяє структурувати ваш код, розділяючи його на окремі файли (модулі).

Важливо розуміти, що під час імпорту модуля Python виконує увесь код, що міститься в модулі. Саме через це модуль з ось таким вмістом:
```
def say_hello(name):
    print(f'Hello {name}')


print("You imported hello.py")
say_hello('user')

Під час імпорту (виконання виразу from hello import say_hello) виведе у консоль:

You imported hello.py
Hello user
```
Далеко не завжди така поведінка бажана.

Точка входу
Що ж робити, коли ми хочемо зробити скрипт, що виконується (який можна викликати із консолі командою python [ім'я скрипта]), але зберегти можливість імпорту з цього модуля, не викликаючи його? В таких випадках нам може допомогти службова змінна Python: __name__. Річ у тому, що якщо скрипт викликаний безпосередньо, то він є "точкою входу" та __name__ == "__main__". Якщо ж цей модуль виконується під час імпорту, то __name__ == "hello" (наприклад для модуля, який називається hello.py). Таким чином ми можемо модифікувати наш модуль hello.py:
```
def say_hello(name):
    print(f'Hello {name}')



if __name__ == '__main__':
    print("You imported hello.py")
    say_hello('user')
```
Тоді під час імпорту функції say_hello із hello.py код у блоці if ... не буде виконаний, а якщо ж в консолі виконати python hello.py, то буде.

Для зручності прийнято весь код, який потрібно виконати, коли модуль викликається із консолі (не імпортується), поміщати у функцію main:
```
def say_hello(name):
    print(f'Hello {name}')

def main():
    print("You imported hello.py")
    say_hello('user')

for arg in sys.argv:
    print(arg)
if __name__ == '__main__':
    main()
```
Так заведено і функцію main ще називають "точкою входу", оскільки робота застосунку починається з виклику цієї функції. Ви, звичайно, можете назвати цю функцію як завгодно, але називати її саме main вважається хорошим тоном.

**Структури даних**

Колекції

Колекція у Python — програмний об'єкт (змінна-контейнер), що зберігає набір значень одного або різних типів.

Простою мовою, колекція — це сховище інформації, каталог, побудований за якимось принципом.

Сховища бувають різними: може бути мішок, з якого ти дістаєш вміст навмання, може бути розкладений за абеткою каталог, в якому дуже легко щось знайти, або труба, з якої можна дістати тільки те, що лежить з краю тощо

Залежно від цілей, можна і треба застосовувати різні колекції. Наприклад, щоб швидко знайти щось, використовують словники; для зберігання впорядкованих даних, коли порядок має значення — списки та кортежі; для зберігання тільки унікальних елементів — множини; для зберігання символів — рядки тощо.

У цьому уроці ми вивчимо основні колекції Python і навчимося працювати з ними. Це основа мови і знання можливостей колекцій є не лише дуже корисною навичкою, але й визначальною для розробника на Python.

Основні властивості колекцій:

Впорядкованість. Впорядкований контейнер (колекція) дає можливість звертатися до своїх елементів за індексом (номером) і гарантує, що порядок елементів зберігається.
Змінність. Якщо колекція змінювана, то її вміст можна змінювати, не створюючи нову колекцію. Наприклад додавати, видаляти, заміняти елементи колекції.
Унікальність. Унікальність стосується вмісту колекції, чи допускається зберігання однакових об'єктів.
Списки
Список — впорядкований змінюваний контейнер даних. Списки не диктують розробнику тип даних, який можна помістити в цей контейнер, і можуть містити будь-які типи даних у будь-якому зручному порядку.

Для створення порожнього списку існує два способи:
```
my_list = list()

empty_list = []

Щоб створити заповнений список:

not_empty = [1, 2, 'user']
```
Впорядковані контейнери
Доступ за індексом
Під впорядкованістю варто розуміти властивість контейнера зберігати порядок елементів при роботі з ним, видаляючи елемент, додаючи новий, роблячи вставку/видалення з кінця/початку/середини, ви гарантуєте, що усі елементи, окрім тих, яких безпосередньо торкнулася операція, зберігають порядок.

Найкориснішою властивістю впорядкованості є можливість доступу до елементів контейнера за індексом цього елемента в контейнері.

У Python синтаксис доступу за індексом виглядає так:
```
some_iterable = ["a", "b", "c"]
first_letter = some_iterable[0]
middle_one = some_iterable[1]
last_letter = some_iterable[2]
```
У першому рядку ми створили список з трьох перших літер англійського алфавіту.

У другому рядку ми зберегли у змінну first_letter літеру "a" — перший елемент some_iterable. Індекс у Python починається з 0, як і в більшості мов програмування, та індексом "a" є 0.

Третій рядок — це звернення до другого елементу some_iterable, його індекс дорівнює 1 — це літера "b" і ми зберігаємо її у middle_one.

Четвертий рядок — це звернення до останнього елементу some_iterable, літери "c", ми збережемо її у last_letter і її індекс дорівнює 2.

Python підтримує індексування елементів з кінця. Для цього потрібно додати - і вказати номер елементу з кінця. Оскільки у Python -0 == 0, то перший елемент з кінця — це -1, другий — -2 і так далі. Наш приклад можна переписати, використовуючи індексування з кінця, ось так:
```
some_iterable = ["a", "b", "c"]
first_letter = some_iterable[-3]
middle_one = some_iterable[-2]
last_letter = some_iterable[-1]
```
Найкориснішою властивістю списків є змінність списків, ви можете змінити значення будь-якого елементу списку:
```
some_iterable = ["a", "b", "c"]
some_iterable[1] = "Z"
print(some_iterable)    # ["a", "Z", "c"]
```
В цьому прикладі ми змінили другий елемент списку some_iterable (другий елемент — це елемент з індексом 1) на 'Z'.

Зрізи у Python (Slice)
Для впорядкованих контейнерів є спеціальний синтаксис, коли нам необхідно отримати деяку послідовність елементів з контейнера. Наприклад, якщо ми хочемо отримати перші 5 літер рядку:
```
some_str = "This is awesome string"
first_five = some_str[0:5]
```
first_five в цьому прикладі буде містити рядок 'This '.

Синтаксис полягає у зазначенні індексу першого елементу зрізу, індексу, до якого (не включно) брати елементи в нову послідовність, та кроку, з яким брати елементи між початковим та кінцевим індексом у квадратних дужках, розділивши їх двокрапкою.

Візьмімо список чисел від 1 до 10 і збережемо окремо парні, не парні та кратні 3.
```
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

odd_numbers = numbers[0:9:2]
even_numbers = numbers[1:9:2]
three_numbers = numbers[2:9:3]
```
У odd_numbers ми беремо числа, починаючи з індексу 0 до 10 з кроком 2 (отримаємо [1, 3, 5, 7, 9]). У even_numbers ми беремо числа, починаючи з індексу 1 до 10 з кроком 2 (отримаємо [2, 4, 6, 8]) У three_numbers ми беремо числа, починаючи з індексу 2 до 10 з кроком 3 (отримаємо [3, 6, 9]).

Ви можете не вказувати початковий, кінцевий індекс або крок, пропускаючи його. За замовчуванням Python візьме зріз з початку до останнього елемента з кроком 1. Перепишемо попередній приклад у скороченому синтаксисі:

numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```
odd_numbers = numbers[::2]
even_numbers = numbers[1::2]
three_numbers = numbers[2:9:3]

numbers_copy = numbers[:]
```
numbers_copy в цьому прикладі — це зріз, який бере всі елементи numbers від початку і до кінця з кроком 1.

Також важливо пам'ятати, що в зріз не входить елемент з індексом, до якого брати елементи.
```
numbers = [0, 1, 2, 3]
first_three = numbers[0:3]  # [0, 1, 2]
```
В цьому прикладі елемент з індексом 3 не увійде у first_three.

Використання методів об'єктів
Об'єкт в програмуванні — деяка сутність у цифровому просторі, що має певний стан і поведінку, має певні властивості (атрибути) та операції над ними (методи).

Доступ до методів об'єктів у Python синтаксично відбувається за допомогою символу крапки після імені об'єкту і зазначення імені методу або атрибуту, до якого потрібно отримати доступ.
```
numbers = ['a', 'b']
numbers.append('c')
print(numbers)  # ['a', 'b', 'c']
```
В цьому прикладі ми використали метод append, який є у списків і він є у списку numbers. Цей метод додає новий елемент в кінець списку. Як аргумент цей метод отримує елемент, який потрібно додати до списку. Аргументи вказуються в дужках.

Якщо метод не вимагає аргументів (наприклад метод clear), то дужки будуть порожніми:
```
num = [1, 2]
num.clear()
print(num)  # []
```
Методи списків
Додавання елементу в кінець списку: my_list.append(element)
```
chars = ['a', 'b']
chars.append('c')
print(chars)  # ['a', 'b', 'c']
```
видалення елементу зі списку викличе помилку, якщо такого елементу немає в списку: my_list.remove(element)
```
chars = ['a', 'b']
chars.remove('b')
print(chars)  # ['a']
```
Повернути i-ий елемент та видалити його зі списку i_element = my_list.pop(i). За замовчуванням i = -1
```
chars = ['a', 'b']
last = chars.pop(1)
print(chars)  # ['a']
print(last)  # 'b'
```
Розширити список a_list елементами з b_list: a_list.extend(b_list)
```
chars = ['a', 'b']
numbers = [1, 2]

chars.extend(numbers)
print(chars)  # ['a', 'b', 1, 2]
```
Вставити x на позицію з індексом i: my_list.insert(i, x)
```
chars = ["a", "b"]
chars.insert(1, "c")
print(chars)  # ['a', 'c', 'b']
```
Очистити список: my_list.clear()
```
chars = ['a', 'b']
last =  chars.clear() print(chars) # []
```
Знайти індекс першого елемента у списку, що дорівнює x: index = my_list.index(x)
```
chars = ['a', 'b', 'c', 'd']
c_ind = chars.index('c') print(c_ind) #2
```
Повернути кількість елементів у списку, що дорівнюють x: x_number = my_list.count(x)
```
chars = ['a', 'b', 'c', 'a']
a_count = chars.count('a')
print(a_count) # 2
```
Відсортувати список за зростанням: my_list.sort(key=None, reverse=False)
```
chars = ['z', 'a', 'b']
chars.sort()
print(chars) # ['a', 'b', 'z']
```
Змінити порядок елементів у списку на зворотний: my_list.reverse()
```
chars = ['a', 'b']
chars.reverse()
print(chars) # ['b', 'a']
```
Повернути копію списку: copy_of_my_list = my_list.copy()
```
chars =  ['a', 'b']
chars_copy = chars.copy()
chars == chars_copy # True
```
Словники
Словник — це контейнер, який зберігає пари ключ-значення. Ключем може бути будь-який незмінний тип даних Python (число, рядок, кортеж тощо). Неможливо використовувати у якості ключа списки, словники, множини або будь-які інші змінювані типи даних. Значенням словника може бути будь-який тип даних Python, включаючи призначені для користувача типи.

Методи словників
Деякі методи словників, що найчастіше використовуються:
```
pop(key) — повертає значення елементу і видаляє пару ключ-значення зі словника
chars = {'a': 1, 'b': 2}
b_num = chars.pop('b')
print(chars)  # {'a': 1}
print(b_num)  # 2

update(another_dict) — розширює словник значеннями з іншого словника
chars = {'a': 1, 'b': 2}
chars.update({"c": 3})
print(chars)  # {'a': 1, 'b': 2, "c": 3}

clear() — очищає словник, не створюючи нового
chars = {'a': 1, 'b': 2}
chars.clear()
print(chars)  # {}

copy() — повертає копію словника
chars = {'a': 1, 'b': 2}
chars_copy = chars.copy()
chars_copy == chars  # True

get(key[, default]) — не викликає виключення, якщо ключа немає в словнику, повертає default, за замовчуванням default=None.
chars = {'a': 1, 'b': 2}
c_idx = chars.get('c', -1)
print(c_idx)  # -1
```
Цикли та словники
Ітерування за словником — це блок коду, що дуже часто зустрічається, і корисно вміти це робити.

Спершу варто сказати, що словник сам по собі — це ітерований контейнер і за ним можна ітеруватися в циклі for без необхідності заводити якийсь зовнішній лічильник тощо. Створимо словник, в якому ключами будуть числа, а значеннями — числівники англійською:
```
numbers = {
    1: "one",
    2: "two",
    3: "three"
}
```

Тепер давайте просто пройдемо словником в циклі та виведемо, що нам повертає ітератор на кожній ітерації:
```
for key in numbers:
    print(key)
```
У виведенні ви побачите:

1
2
3

Ітеруючи за словником, ви перебираєте ключі словника. Таку саму поведінку можна отримати, використовуючи метод keys, але так ви явно вкажете, що хочете перебрати ключі:
```
for key in numbers.keys():
    print(key)
```
Відповідь буде точно такою самою:

1
2
3

Часто необхідно перебрати саме значення словника, для цього скористаємося методом values:
```
for val in numbers.values():
    print(val)
```
У виведенні буде:

one
two
tree

І переберемо пари ключ значення, використовуючи метод items. На кожній ітерації ми отримаємо пару (ключ, значення):
```
for key, value in numbers.items():
    print(key, value)
```
Виведення:

1 one
2 two
3 three

Що не можна робити, поки ітеруєтеся за словником: не можна видаляти елементи із словника, не можна додавати елементи у словник. Але можна перезаписувати значення, якщо ви ітеруєтеся за ключами.

Множини
Множини — це неврегульований контейнер, який містить тільки унікальні елементи. У множину можна додавати тільки незмінні типи даних.

Є тільки один спосіб створити порожню множину:
```
a = set()
print(a)    # set()
```
Для створення заповненої множини достатньо передати будь-який об'єкт, що ітерується, в функцію set:
```
a = set('hello')
print(a)    # {'e', 'h', 'l', 'o'}
```
Або ж скористатися синтаксисом з фігурними дужками (як у словниках), але елементи у фігурних дужках просто перелічити через кому без двокрапок:
```
b = {1, 2, 3, 4}
```
Унікальність має на увазі, що якщо множина вже містить такий елемент, то спроба додати ще один такий самий нічого не змінить.
```
numbers = {1, 2, 3, 1, 2, 3}
print(numbers)    # {1, 2, 3}
```
Методи множин
Множини підтримують наступні методи:
```
add(elem) — додає елемент в множину
numbers = {1, 2, 3}
numbers.add(4)
print(numbers)    # {1, 2, 3, 4}

remove(elem) — видаляє елемент з множини, викликає виняток, якщо такого елементу немає
numbers = {1, 2, 3}
numbers.remove(3)
print(numbers)    # {1, 2}

discard(elem) — видаляє елемент з множини і не викликає виняток, якщо його немає
numbers = {1, 2, 3}
numbers.discard(2)
print(numbers)    # {1, 3}
```
Математичні операції над множинами
Давайте детальніше розглянемо, які корисні математичні операції можна робити над множинами. Спершу створимо множини a та b:
```
a = set('hello')
print(a)    # {'e', 'h', 'l', 'o'}

b = set('hi there!')
print(b)    # {'r', ' ', 'i', 'e', '!', 'h', 't'}
```
Щоб знайти загальні елементи для двох множин, виконаємо над ними операцію & (AND):
`
a & b   # {'e', 'h'}
`
Знайдемо усі елементи з двох множин, окрім загальних, за допомогою оператора ^ (XOR):
`
a ^ b   # {' ', '!', 'i', 'l', 'o', 'r', 't'}
`
Об'єднання множин, або просто усі елементи з обох множин знаходяться за допомогою оператора | (OR):
`
a | b   # {' ', '!', 'e', 'h', 'i', 'l', 'o', 'r', 't'}
`
Множини — це дуже потужний інструмент, коли необхідно знайти унікальні елементи в якомусь наборі і прибрати дублікати. Множини — це також найшвидший спосіб знайти загальні або відмінні елементи з декількох наборів.

Використання кортежів як ключів
Незмінність кортежів обмежує їх застосування, у порівнянні зі списками, але дає можливість використати кортежі як ключі для словника, або елементи множини. Наприклад, розглянемо набір точок на площині (кортежі). Їх можна використовувати як ключі у словнику:
```
points = {
    (0, 0): "O"
    (1, 1): "A"
    (2, 2): "B"
}
```
У словнику points використовуються кортежі з координатами точок як ключі, а значення — це імена (назва) точок.

При спробі змінити кортеж ви отримаєте повідомлення про помилку:
````
not_empty[3] = 's'
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-6-0e33ea041f91> in <module>()
----> 1 not_empty[3] = 's'
````
TypeError: 'tuple' object does not support item assignment

Є одна важлива особливість створення кортежів — це створення кортежів з одним елементом. Річ у тому, що Python використовує круглі дужки як математичні символи. Якщо написати вираз на кшталт a = (1), виникає невизначеність. Інтерпретатор розуміє такий вираз, як суто математичний, і просто прибирає зайві дужки, присвоюючи a значення 1. Щоб вказати, що це не математична операція, а саме кортеж, потрібно додати кому після значення. Тоді інтерпретатор однозначно зрозуміє, що ви хочете створити кортеж з одним елементом:
``
a = (1, )
``
Рядки
Робота з текстовими даними у Python реалізована через str-об'єкти або рядки.
Рядок — це незмінна впорядкована послідовність символів в деякому кодуванні. За замовчуванням використовується кодування UTF-8, але можна працювати майже з усіма відомими таблицями кодування символів. Для того щоб створити змінну типу "рядок", необхідно певний набір символів взяти в лапки.

Варіант 1. Одинарні лапки (апостроф) 'some text'
Варіант 2. Подвійні лапки "some text".
Різні варіанти використання лапок обумовлені тим, що при використанні одинарних лапок, можна в рядку вказати подвійні і навпаки.
``
game_string = 'My "Game"'
``
Впорядкована послідовність означає, що до елементів рядку можна звертатися за індексом:
```
s = "Hello world!"
print(s[0])   # H
print(s[-1])  # !
```
Незмінна послідовність означає, що якщо рядок вже створений, то змінити його не можна, можна тільки створити новий.
```
s = "Hello world!"
s[0] = "Q" # Тут буде викликано виняток (помилка) TypeError
```
Малі методи

Для того, щоб усі літери рядка перевести у верхній регістр, використовується метод upper:
````
s = "Hello"
s.upper()
print(s)    # Виведе 'HELLO'
````
Для переведення в нижній регістр використовується метод lower():
````
s = "Some Text"
print(s.lower())    # Виведе 'some text'
````
Щоб перевірити, що рядок починається з підрядка, є метод startswith:
````
s = "Bill Jons"
print(s.startswith("Bi"))   # Виведе True
````
Щоб перевірити, що рядок закінчується підрядком, використовується метод endswith:
````
s = "hello.jpg"
print(s.endswith("jpg"))    # Виведе True
````
Цей метод зручно використовувати для перевірки розширення файлів.

Загальні для усіх колекцій операції
Такі різні списки, кортежі, словники, множини і рядки об'єднують в одну групу — колекції, тому що в них є загальні властивості:

перевірка на входження;
кількість елементів;
перебір усіх елементів в циклі for.
Перевірка на входження
Будь-яка колекція дозволяє перевірити, чи містить колекція цей елемент (чи є там такий самий). Для цього використовується оператор in.

Наприклад, перевірка на те, що користувач не використовує простий пароль і в паролі не зустрічається послідовність "qwerty" або "123":
````
password = "qwerty123"
if "qwerty" in password or "123" in password:
    print("This password is too weak!")
````
Оператор in перевіряє наявність елементу ('qwerty', '123') у контейнері (password) та повертає True або False.
````
prime_numbers = {2, 3, 5, 7, 11, 13, 17, 19, 23}
is_prime = 3 in prime_numbers
````
Перевірка на те, що число 3 присутнє у множині перших дев'яти простих чисел prime_numbers.

Із словниками перевірка на входження перевіряє, що елемент присутній серед ключів словника.
````
user = {
    "name": "Bill",
    "surname": "Bosh",
    "age": 22
}

if "age" in user:
    print(f"User is {user['age']} years old.")
````
Кількість елементів
Будь-яка колекція дозволяє дізнатися кількість елементів у ній за допомогою функції len.
````
password = input("Password: ")
if len(password) < 8:
    print("Your password is too short")
````
Наприклад, перевірка довжини пароля введеного користувача може бути реалізована за допомогою функції len.

Перебір усіх елементів колекції в циклі for
````
alphabet = "abcdefghijklmnopqrstuvwxyz"
for char in alphabet:
    print(char)
````
По будь-якій колекції можна пройти за допомогою циклу for і на кожній ітерації в циклі буде отриманий один з елементів цієї колекції. У прикладі літери алфавіту з alphabet виводяться в консоль по черзі в циклі for.

Давайте проітеруємо список some_iterable у циклі та виведемо в консоль, що ми отримуємо на кожній ітерації:
````
some_iterable = ["a", "b", "c"]

for i in some_iterable:
    print(i)
````
У консолі ми побачимо:

a
b
c
````
odd_numbers = [1, 3, 5, 7, 9]
for i in odd_numbers:
    print(i ** 2)
````
Код з цього прикладу виведе в консоль квадрати перших п'яти непарних чисел.

Робота з файловою системою, пакет pathlib
Для роботи з файловою системою в стандартному постачанні Python йде пакет pathlib, він містить безліч корисних функцій для роботи з файловою системою. Детальний перелік можливостей pathlib рекомендуємо вивчити на сторінці офіційної документації.

Основний інструмент у pathlib — Path, об'єкт, який є шляхом (адреса у файловій системі). В основному робота з файловою системою ведеться через Path. Path варто сприймати як вказівку на файл або папку. Щоб створити такий Path, достатньо викликати Path як функцію та передати у якості аргументу рядок-адресу у файловій системі:

from pathlib import Path
``
p = Path('/home/user/Downloads')    # p Вказує на папку /home/user/Downloads
``
Можна викликати Path без аргументів, тоді ви отримаєте вказівник на папку, в якій ви зараз знаходитеся.
````
from pathlib import Path

p = Path()  # p Вказує на папку, з якої був запущений Python
````
У Path є ряд корисних методів та атрибутів:

p.parent вказує на батьківську папку;

p.name повертає лише ім'я (рядок) папки або файлу, на який вказує p;

p.suffix повертає рядком розширення файлу, на який вказує p, починаючи з крапки;

p = Path('setup.py')
p.suffix    # '.py'

p.exists() повертає True або False, залежно від того, чи існує такий файл або папка;

p.is_dir() повертає True, якщо p вказує на папку, та False, якщо на файл, або такий шлях не існує;

p.is_file() повертає True, якщо p вказує на файл, та False, якщо на папку, або такий шлях не існує;

p.iterdir() повертає ітератор за всіма файлам та папками всередині папки p;
````
from pathlib import Path

p = Path('/home/user/Downloads')    # p Вказує на папку /home/user/Downloads
for i in p.iterdir():
    print(i.name)   # Виведе у циклі імена всіх папок та файлів у /home/user/Downloads
````
Варто розуміти, що i в цьому прикладі також будуть об'єктами Path, але вказувати вони будуть на файли та папки всередині '/home/user/Downloads'.

З концепцією об'єктів ми познайомимося дещо пізніше, поки достатньо знати, що i — це як і p теж вказівники на папки і файли, але кожен i вказує на якийсь свій файл або папку.

Обробка аргументів командного рядка
Коли запускаємо збережений у файлі Python скрипт, є можливість передати йому при запуску якісь аргументи, як у функцію. Тоді наш скрипт може ці аргументи прийняти і якось змінити свою поведінку. Зробити це можна за допомогою пакета sys, в якому є список argv, де з'являються всі аргументи, з якими був запущений скрипт.

Цікавою особливістю sys.argv є те, що першим елементом цього списку буде назва самого файлу скрипту. Всі аргументи будуть у sys.argv у вигляді рядків в тому самому порядку, в якому вони були передані під час виклику. Python розділяє аргументи пробілами і в sys.argv пробіли не потрапляють.

Щоб зрозуміти як працює sys.argv, можете зробити простий скрипт echo.py, який буде виводити у консоль всі передані при виклику аргументи.
````
import sys

for arg in sys.argv:
    print(arg)
````
Якщо викликати скрипт з таким вмістом (припустимо він називається echo.py) командою: python echo.py test --user -hello some text, то у консолі ви побачите:
````
echo.py
test
--user
-hello
some
text
````
Таким чином, якщо вам потрібно обробити перший аргумент запуску:
````
import sys


def main():
    print(sys.argv[1])
````
Під час виклику такого скрипту командою python echo.py 123 ви побачите у консолі 123. Зверніть увагу, що всі елементи списку sys.argv — це рядки. Якщо ви очікуєте, що користувач повинен ввести число (ціле або дробове), то вам потрібно перетворити рядок в потрібний вам тип самостійно.