**Керуючі конструкції, цикли, виключення
Функції, Структури данних**

**Завдання №1**

Досить часто програмісти стикаються із завданнями кодування інформації. Закодувати повідомлення в чаті між двома користувачами. Зашифрувати пароль та ім'я користувача при автентифікації користувача через мережу і т.і.

Напишіть програму, що реалізує код Цезаря. Він названий на честь великого римського імператора Юлія Цезаря.

Ідея шифрування полягає у циклічному зміщенні букв на задану кількість. Наприклад, якщо зміщення на три позиції, то літера A стає літерою D, B – E тощо. Останні три літери алфавіту зациклюються та переносяться на початок. Літера X стає A, Y – B, а Z – C. Цифри, пробіли та інші символи не шифруються.

У програмі користувач вводить фразу та число для зсуву, після чого треба вирахувати нове закодоване повідомлення.

Програма шифруватиме як малі (a-z), так і великі літери (A-Z).

Для розв'язку цього завдання знадобиться знання двох нових функцій. Перша функція ord. Вона перетворює символ на число, яке є позицією в таблиці ASCII.

`ord("a")  # 97
`Можна вважати, що отриманий результат '97' — це числове представлення символу a для комп'ютера.

Зворотна функція chr повертає рядковий символ у таблиці ASCII за позицією, переданою як аргумент.

`chr(118)  # 'v'`
Детальніший принцип шифрування.

Розглянемо для прикладу як зашифрувати символ v. Щоб отримати позицію символу v щодо початкового символу a, необхідно виконати вираз

`pos = ord('v') - ord('a')  # 21`
Але, згідно з алгоритмом, нам необхідно враховувати зсув, який може бути довільним, наприклад, 33. І пам'ятати, що алфавіт англійської мови заснований на латинському алфавіті та складається з 26 літер. Тому кінцева позиція символу v щодо символу a для шифрування з урахуванням цього — дорівнює 2.

```
pos = ord('v') - ord('a')  # 21
pos = (pos + 33) % 26  # 2
```
Залишився останній крок, отримати новий символ:

```
pos = ord('v') - ord('a')  # 21
pos = (pos + 33) % 26  # 2
new_char = chr(pos + ord("a"))  # 'c
```
Символ v зі зміщенням 33 шифрується символом c.

Тести перевіряють та кодують наступні рядки:
```
"Hello my little friends!", offset = 37,
"Hello world!", offset = 7
```

**Завдання №2**

Напишіть програму, яка буде виконувати найпростіші математичні операції з числами послідовно, приймаючи від користувача операнди (числа) та оператор.

Умови для цієї задачі

Додаток працює з цілими та дійсними числами.
Додаток вміє виконувати такі математичні операції:
ДОДАВАННЯ (+)
ВІДНІМАННЯ(-)
МНОЖЕННЯ (*)
ДІЛЕННЯ (/)
Програма приймає один операнд або один оператор за один цикл запит-відповідь.
Всі операції програма виконує в порядку надходження — одну за одною.
Програма виводить результат обчислень, коли отримує від користувача символ =.
Додаток закінчує роботу після того, як виведе результат обчислення.
Користувач по черзі вводить числа та оператори.
Якщо користувач вводить оператор двічі поспіль, він отримує повідомлення про помилку і може ввести повторно.
Якщо користувач вводить число двічі поспіль, він отримує повідомлення про помилку і може ввести повторно.
Додаток коректно опрацьовує ситуацію некоректного введення (exception).
Початкові змінні:

```
result = None
operand = None
operator = None
wait_for_number = 
```
result — сюди поміщаємо підсумковий результат operand — завжди зберігає поточне число operator — рядковий параметр, може містити чотири значення, "+", "-", "*", "/" wait_for_number — прапорець, який вказує, що очікують на вводі оператор (operator) або операнд (operand)

Приклад виконання програми:

`````>>> 3
>>> +
>>> 3
>>> 2
2 is not '+' or '-' or '/' or '*'. Try again
>>> -
>>> -
'-' is not a number. Try again.
>>> 5
>>> *
>>> 3
>>> =
`````
**Завдання №3**

Параметри функцій можна встановлювати за замовчуванням. Вони присвоюються в першому рядку визначення функції:

```
def fun(a, b=2, c=3):
    return a + b * c
```
У цьому прикладі, якщо є тільки один обов'язковий параметр a при виклику функції fun, інші значення для локальних змінних b і c ми вказуємо відразу при визначенні функції.

Значення за замовчуванням можуть бути у будь-якої кількості параметрів. Але є важливий момент — параметри за замовчуванням повинні визначатися останніми у списку параметрів, тому що при виклику функції аргументи зіставляються з параметрами згідно з їхніми позиціями при оголошенні функції. Таким чином, у списку параметрів функції параметр зі значенням за замовчуванням не може знаходитись перед параметром без значення за замовчуванням.

**Завдання №4**

Однією з класичних задач на розуміння рекурсії, яку часто задають на співбесідах, особливо початківцям-програмістам — це ряд Фібоначчі.

Ряд Фібоначчі — це послідовність чисел виду: '0, 1, 1, 2, 3, 5, 8, ...' де кожне наступне число послідовності виходить додаванням двох попередніх членів ряду.

У загальному вигляді для обчислення n-го члена ряду Фібоначчі слід обчислити вираз:

`Fn = Fn-1 + Fn-2.
`
Це завдання можна вирішити рекурсивно, викликаючи функцію, що обчислює числа послідовності доти, доки виклик не сягне членів ряду менше n = 1, на якій задана послідовність

**Завдання №5**

У нас є список показань заборгованостей з комунальних послуг наприкінці місяця. Заборгованості можуть бути від'ємними — у нас переплата, чи додатними, якщо необхідно сплатити за рахунками. Напишіть функцію `amount_payment`, яка приймає на вхід список платежів, підсумовує додатні значення та повертає суму платежу наприкінці місяця.

**Завдання №6**

Як ми знаємо, ключ у словнику має бути унікальним, тоді як значення його ні. Реалізуйте функцію lookup_key для пошуку всіх ключів за значенням у словнику. Першим параметром у функцію ми передаємо словник, а другим — значення, що хочемо знайти. Таким чином, результат може бути як список ключів, так і порожній список, якщо ми нічого н

**Завдання №7**

Всім відомо, що для доступу до кредитної картки банку потрібний пін-код. Класично склалося, що це поєднання чотири цифри. Нам необхідно вирішити наступне програмістське завдання. Є підготовлений перелік пін-кодів. Напишіть функцію is_valid_pin_codes, яка буде приймати як параметр список цих пін-кодів — рядок з чотирьох цифр і повертати логічне значення — валідний список чи ні. Переконайтеся, що серед цих пін-кодів у списку не буде дублікатів, всі вони зберігаються у вигляді рядків, їх довжина дорівнює 4 символам і містять вони тільки цифри.

Приклад аргументу для функції is_valid_pin_codes:

`['1101', '9034', '0011']`

Якщо список відповідає всім поставленим умовам, функція повертає логічне значення True. Якщо хоч одну з умов порушено, повертається значення — False. Передбачити перевірку на порожній список в аргументі функції та повернути при цьому значення False.

**Завдання №8**

Теорія до завдання

Обробка аргументів командного рядка в Python здійснюється за допомогою модуля sys.

Отримати передані при запуску скрипту аргументи можна через список argv з пакета sys, де з'являються всі аргументи, з якими було запущено скрипт. Змінна sys.argv є списком рядків. Вона містить список аргументів командного рядка, тобто аргументів, переданих програмі із командного рядка.

Наприклад, створимо файл test.py з таким вмістом:
```
import sys

for arg in sys.argv:
    print(arg)
```

Якщо ми запустимо наш скрипт і передамо до нього аргументи,

```
python test.py -help user --flag
```

то отримаємо наступний вивід у консолі
```
test.py
-help
user
--flag
```

Цікавою особливістю sys.argv є те, що першим елементом цього списку буде назва файлу скрипту test.py. Всі аргументи будуть в sys.argv у вигляді рядків у тому самому порядку, в якому вони були передані при виклику скрипту. Якщо ви очікуєте, що користувач повинен ввести число (ціле або дійсне), то вам потрібно перетворити рядок на потрібний вам тип самостійно. Python розділяє аргументи пробілами та в sys.argv пробіли не потрапляють.

Завдання

Створіть функцію `parse_args`, яка повертає рядок, складений з аргументів командного рядка, розділених пробілами. Наприклад, якщо скрипт був викликаний командою: `python run.py first second`, то функція parse_args повинна повернути рядок наступного виду `'first second'`.